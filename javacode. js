const gameBoard = document.getElementById('game-board');
const scoreElement = document.getElementById('score');

const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
let score = 0;

// Create the game board
for (let i = 0; i < BOARD_WIDTH * BOARD_HEIGHT; i++) {
  const cell = document.createElement('div');
  cell.classList.add('cell');
  gameBoard.appendChild(cell);
}

const cells = Array.from(gameBoard.querySelectorAll('.cell'));

const TETROMINOES = {
  'I': { shape: [[1, 1, 1, 1]], color: 'I' },
  'J': { shape: [[1, 0, 0], [1, 1, 1]], color: 'J' },
  'L': { shape: [[0, 0, 1], [1, 1, 1]], color: 'L' },
  'O': { shape: [[1, 1], [1, 1]], color: 'O' },
  'S': { shape: [[0, 1, 1], [1, 1, 0]], color: 'S' },
  'T': { shape: [[0, 1, 0], [1, 1, 1]], color: 'T' },
  'Z': { shape: [[1, 1, 0], [0, 1, 1]], color: 'Z' }
};

let currentTetromino;
let currentPosition;
let currentRow = 0;
let currentCol = 3;

function getRandomTetromino() {
  const tetrominoNames = Object.keys(TETROMINOES);
  const randomName = tetrominoNames[Math.floor(Math.random() * tetrominoNames.length)];
  return TETROMINOES[randomName];
}

function draw() {
  currentTetromino.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        const cellIndex = (currentRow + y) * BOARD_WIDTH + (currentCol + x);
        cells[cellIndex].classList.add('tetromino', currentTetromino.color);
      }
    });
  });
}

function undraw() {
  currentTetromino.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        const cellIndex = (currentRow + y) * BOARD_WIDTH + (currentCol + x);
        cells[cellIndex].classList.remove('tetromino', currentTetromino.color);
      }
    });
  });
}

function moveDown() {
  undraw();
  currentRow++;
  if (hasCollision()) {
    currentRow--;
    lockTetromino();
    spawnNewTetromino();
  }
  draw();
}

function moveLeft() {
  undraw();
  currentCol--;
  if (hasCollision()) {
    currentCol++;
  }
  draw();
}

function moveRight() {
  undraw();
  currentCol++;
  if (hasCollision()) {
    currentCol--;
  }
  draw();
}

function rotate() {
    undraw();
    const originalShape = currentTetromino.shape;
    const rotatedShape = currentTetromino.shape[0].map((_, colIndex) =>
        currentTetromino.shape.map(row => row[colIndex]).reverse()
    );
    currentTetromino.shape = rotatedShape;
    if (hasCollision()) {
        currentTetromino.shape = originalShape;
    }
    draw();
}

function hasCollision() {
    for (let y = 0; y < currentTetromino.shape.length; y++) {
        for (let x = 0; x < currentTetromino.shape[y].length; x++) {
            if (
                currentTetromino.shape[y][x] &&
                (cells[(currentRow + y) * BOARD_WIDTH + (currentCol + x)]?.classList.contains('locked') ||
                    currentCol + x < 0 ||
                    currentCol + x >= BOARD_WIDTH ||
                    currentRow + y >= BOARD_HEIGHT)
            ) {
                return true;
            }
        }
    }
    return false;
}


function lockTetromino() {
  currentTetromino.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        const cellIndex = (currentRow + y) * BOARD_WIDTH + (currentCol + x);
        cells[cellIndex].classList.add('locked');
      }
    });
  });
  clearLines();
}

function clearLines() {
    let linesCleared = 0;
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        const rowStartIndex = y * BOARD_WIDTH;
        const rowCells = cells.slice(rowStartIndex, rowStartIndex + BOARD_WIDTH);

        if (rowCells.every(cell => cell.classList.contains('locked'))) {
            linesCleared++;
            // Remove the row from the DOM
            rowCells.forEach(cell => cell.remove());
            
            // Remove from the cells array
            cells.splice(rowStartIndex, BOARD_WIDTH);

            // Create a new row of cells and prepend to the board
            const newRow = Array.from({ length: BOARD_WIDTH }, () => {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                return cell;
            });
            gameBoard.prepend(...newRow);
            
            // Add new row to the beginning of the cells array
            cells.unshift(...newRow);

            y++; // Check the same row again because the content has shifted down
        }
    }

    if (linesCleared > 0) {
        score += linesCleared * 10;
        scoreElement.textContent = score;
    }
}


let timerId;
const gameOverOverlay = document.getElementById('game-over-overlay');
const restartButton = document.getElementById('restart-button');

function spawnNewTetromino() {
  currentTetromino = getRandomTetromino();
  currentRow = 0;
  currentCol = 3;
  if (hasCollision()) {
    gameOver();
  }
}

function gameOver() {
    clearInterval(timerId);
    gameOverOverlay.classList.remove('hidden');
}

function resetGame() {
    // Clear the board
    cells.forEach(cell => cell.classList.remove('locked', 'tetromino', ...Object.values(TETROMINOES).map(t => t.color)));
    
    // Reset score
    score = 0;
    scoreElement.textContent = score;

    // Hide game over screen
    gameOverOverlay.classList.add('hidden');
    
    // Start the game again
    spawnNewTetromino();
    draw();
    timerId = setInterval(moveDown, 1000);
}

function drop() {
    undraw();
    while (!hasCollision()) {
        currentRow++;
    }
    currentRow--;
    draw();
    lockTetromino();
    spawnNewTetromino();
}

spawnNewTetromino();
draw();

timerId = setInterval(moveDown, 1000);

restartButton.addEventListener('click', resetGame);

document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') {
    moveLeft();
  } else if (e.key === 'ArrowRight') {
    moveRight();
  } else if (e.key === 'ArrowDown') {
    moveDown();
  } else if (e.key === 'ArrowUp') {
    rotate();
  } else if (e.key === ' ') {
    drop();
  }
});

document.getElementById('left').addEventListener('click', moveLeft);
document.getElementById('right').addEventListener('click', moveRight);
document.getElementById('down').addEventListener('click', moveDown);
document.getElementById('up').addEventListener('click', rotate);
document.getElementById('rotate').addEventListener('click', rotate);
document.getElementById('drop').addEventListener('click', drop);